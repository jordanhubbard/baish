This file is ask.def, from which is created ask.c.
It implements the baish builtin "ask".

Copyright (C) 2026

$PRODUCES ask.c

#include <config.h>

#include "../bashtypes.h"
#include "../bashansi.h"

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

#include "../shell.h"
#include "../bashintl.h"
#include "../variables.h"
#include "../xmalloc.h"

#include "common.h"

$BUILTIN ask
$FUNCTION ask_builtin
$SHORT_DOC ask [question...]
Ask the configured model a question; optionally execute returned shell commands.

Configuration variables:
  BAISH_OPENAI_BASE_URL  Base URL like http://host:port/v1
  BAISH_MODEL            Model name
  BAISH_AUTOEXEC         If set (non-zero), execute returned commands without prompting
  OPENAI_API_KEY         Optional bearer token

Results variables:
  BAISH_LAST_ANSWER      Last answer string
  BAISH_LAST_COMMANDS    Newline-separated commands (if any)

The model is asked to return JSON: {"answer":..., "commands":[...]}. If parsing
fails, the raw model content is used as the answer.
$END

static const char *
baish_skip_ws (const char *p)
{
  while (p && (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n'))
    p++;
  return p;
}

static int
baish_truthy (const char *s)
{
  if (s == 0)
    return 0;
  s = baish_skip_ws (s);
  if (*s == 0)
    return 0;
  if (STREQ (s, "0") || STREQ (s, "false") || STREQ (s, "FALSE") || STREQ (s, "no") || STREQ (s, "NO"))
    return 0;
  return 1;
}

static int
baish_ascii_tolower (int c)
{
  if (c >= 'A' && c <= 'Z')
    return c + ('a' - 'A');
  return c;
}

static const char *
baish_strcasestr (const char *haystack, const char *needle)
{
  size_t nlen;
  const char *h;

  if (haystack == 0 || needle == 0)
    return 0;
  nlen = strlen (needle);
  if (nlen == 0)
    return haystack;

  for (h = haystack; *h; h++)
    {
      size_t i;
      for (i = 0; i < nlen; i++)
        {
          if (h[i] == 0)
            break;
          if (baish_ascii_tolower ((unsigned char)h[i]) != baish_ascii_tolower ((unsigned char)needle[i]))
            break;
        }
      if (i == nlen)
        return h;
    }
  return 0;
}

static char *
baish_slurp_stream (FILE *fp, size_t *lenp)
{
  size_t cap, len;
  char *buf;
  size_t n;

  cap = 4096;
  len = 0;
  buf = (char *)xmalloc (cap);

  while (1)
    {
      if (len + 2048 >= cap)
        {
          cap *= 2;
          buf = (char *)xrealloc (buf, cap);
        }
      n = fread (buf + len, 1, cap - len - 1, fp);
      if (n == 0)
        break;
      len += n;
    }

  buf[len] = '\0';
  if (lenp)
    *lenp = len;
  return buf;
}

static char *
baish_json_escape (const char *s)
{
  size_t i, o, cap;
  char *out;

  if (s == 0)
    return savestring ("");

  cap = strlen (s) * 2 + 32;
  out = (char *)xmalloc (cap);
  o = 0;

  for (i = 0; s[i]; i++)
    {
      unsigned char c = (unsigned char)s[i];
      if (o + 8 >= cap)
        {
          cap *= 2;
          out = (char *)xrealloc (out, cap);
        }
      switch (c)
        {
        case '\\': out[o++]='\\'; out[o++]='\\'; break;
        case '"': out[o++]='\\'; out[o++]='"'; break;
        case '\b': out[o++]='\\'; out[o++]='b'; break;
        case '\f': out[o++]='\\'; out[o++]='f'; break;
        case '\n': out[o++]='\\'; out[o++]='n'; break;
        case '\r': out[o++]='\\'; out[o++]='r'; break;
        case '\t': out[o++]='\\'; out[o++]='t'; break;
        default:
          if (c < 0x20)
            {
              static const char hex[] = "0123456789abcdef";
              out[o++]='\\'; out[o++]='u'; out[o++]='0'; out[o++]='0';
              out[o++]=hex[(c>>4)&0xf];
              out[o++]=hex[c&0xf];
            }
          else
            out[o++] = (char)c;
          break;
        }
    }
  out[o] = '\0';
  return out;
}

static char *
baish_json_parse_string (const char **pp)
{
  const char *p;
  size_t cap, o;
  char *out;

  p = *pp;
  if (p == 0 || *p != '"')
    return 0;
  p++;

  cap = 128;
  out = (char *)xmalloc (cap);
  o = 0;

  while (*p)
    {
      unsigned char c = (unsigned char)*p++;
      if (c == '"')
        break;
      if (c == '\\')
        {
          unsigned char e = (unsigned char)*p++;
          switch (e)
            {
            case '"': c = '"'; break;
            case '\\': c = '\\'; break;
            case '/': c = '/'; break;
            case 'b': c = '\b'; break;
            case 'f': c = '\f'; break;
            case 'n': c = '\n'; break;
            case 'r': c = '\r'; break;
            case 't': c = '\t'; break;
            case 'u':
              if (p[0] && p[1] && p[2] && p[3])
                p += 4;
              c = '?';
              break;
            default:
              c = e;
              break;
            }
        }

      if (o + 2 >= cap)
        {
          cap *= 2;
          out = (char *)xrealloc (out, cap);
        }
      out[o++] = (char)c;
    }

  out[o] = '\0';
  *pp = p;
  return out;
}

static int
baish_parse_http_base_url (const char *base, char **hostp, char **portp, char **pathp)
{
  const char *p, *host_start;
  const char *host_end, *port_start, *path_start;
  char *host, *port, *path;

  if (base == 0)
    return 0;

  p = base;
  if (STREQN (p, "http://", 7) == 0)
    return 0;
  p += 7;

  host_start = p;
  while (*p && *p != ':' && *p != '/')
    p++;
  host_end = p;
  if (host_end == host_start)
    return 0;

  port_start = 0;
  if (*p == ':')
    {
      p++;
      port_start = p;
      while (*p && *p != '/')
        p++;
    }

  path_start = (*p == '/') ? p : 0;

  host = (char *)xmalloc ((host_end - host_start) + 1);
  strncpy (host, host_start, host_end - host_start);
  host[host_end - host_start] = '\0';

  if (port_start)
    {
      const char *port_end = p;
      port = (char *)xmalloc ((port_end - port_start) + 1);
      strncpy (port, port_start, port_end - port_start);
      port[port_end - port_start] = '\0';
    }
  else
    port = savestring ("80");

  if (path_start)
    path = savestring (path_start);
  else
    path = savestring ("/v1");

  *hostp = host;
  *portp = port;
  *pathp = path;
  return 1;
}

static char *
baish_http_post (const char *host, const char *port, const char *path, const char *auth_bearer, const char *body)
{
  struct addrinfo hints, *res, *rp;
  int sfd;
  int ga;
  size_t bodylen;
  char *req;
  size_t reqlen;
  char *resp;
  size_t cap, len;
  ssize_t n;

  memset (&hints, 0, sizeof (hints));
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_family = AF_UNSPEC;

  ga = getaddrinfo (host, port, &hints, &res);
  if (ga != 0)
    return 0;

  sfd = -1;
  for (rp = res; rp; rp = rp->ai_next)
    {
      sfd = socket (rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if (sfd < 0)
        continue;
      if (connect (sfd, rp->ai_addr, rp->ai_addrlen) == 0)
        break;
      close (sfd);
      sfd = -1;
    }
  freeaddrinfo (res);
  if (sfd < 0)
    return 0;

  bodylen = body ? strlen (body) : 0;
  if (auth_bearer && *auth_bearer)
    {
      reqlen = bodylen + strlen (host) + strlen (path) + strlen (auth_bearer) + 256;
      req = (char *)xmalloc (reqlen);
      snprintf (req, reqlen,
                "POST %s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Bearer %s\r\n"
                "Connection: close\r\n"
                "Content-Length: %lu\r\n"
                "\r\n"
                "%s",
                path, host, auth_bearer, (unsigned long)bodylen, body ? body : "");
    }
  else
    {
      reqlen = bodylen + strlen (host) + strlen (path) + 192;
      req = (char *)xmalloc (reqlen);
      snprintf (req, reqlen,
                "POST %s HTTP/1.1\r\n"
                "Host: %s\r\n"
                "Content-Type: application/json\r\n"
                "Connection: close\r\n"
                "Content-Length: %lu\r\n"
                "\r\n"
                "%s",
                path, host, (unsigned long)bodylen, body ? body : "");
    }

  {
    const char *p = req;
    size_t left = strlen (req);
    while (left)
      {
        n = write (sfd, p, left);
        if (n <= 0)
          {
            free (req);
            close (sfd);
            return 0;
          }
        p += n;
        left -= (size_t)n;
      }
  }
  free (req);

  cap = 8192;
  len = 0;
  resp = (char *)xmalloc (cap);

  while ((n = read (sfd, resp + len, cap - len - 1)) > 0)
    {
      len += (size_t)n;
      if (len + 4096 >= cap)
        {
          cap *= 2;
          resp = (char *)xrealloc (resp, cap);
        }
    }

  close (sfd);
  resp[len] = '\0';
  return resp;
}

static char *
baish_http_body (const char *resp)
{
  const char *p, *body;
  char *headers;
  char *decoded;

  p = resp ? strstr (resp, "\r\n\r\n") : 0;
  if (p == 0)
    return 0;

  {
    size_t hlen = (size_t)(p - resp);
    headers = (char *)xmalloc (hlen + 1);
    memcpy (headers, resp, hlen);
    headers[hlen] = '\0';
  }
  body = p + 4;

  decoded = 0;
  if (headers && (baish_strcasestr (headers, "Transfer-Encoding: chunked") != 0))
    {
      const char *bp = body;
      size_t cap = 4096;
      size_t len = 0;

      decoded = (char *)xmalloc (cap);
      while (bp && *bp)
        {
          unsigned long chunk;
          char *endp;

          chunk = strtoul (bp, &endp, 16);
          if (endp == (char *)bp)
            { free (decoded); decoded = 0; break; }

          bp = strstr (endp, "\r\n");
          if (bp == 0)
            { free (decoded); decoded = 0; break; }
          bp += 2;

          if (chunk == 0)
            break;

          if (len + chunk + 1 >= cap)
            {
              while (len + chunk + 1 >= cap)
                cap *= 2;
              decoded = (char *)xrealloc (decoded, cap);
            }

          memcpy (decoded + len, bp, chunk);
          len += chunk;
          bp += chunk;

          if (bp[0] == 0 || bp[1] == 0 || bp[0] != '\r' || bp[1] != '\n')
            { free (decoded); decoded = 0; break; }
          bp += 2;
        }

      if (decoded)
        decoded[len] = '\0';
    }

  free (headers);
  if (decoded)
    return decoded;
  return savestring (body);
}

static char *
baish_extract_message_content (const char *json)
{
  const char *p;

  if (json == 0)
    return 0;

  p = strstr (json, "\"message\"");
  if (p)
    p = strstr (p, "\"content\"");
  if (p == 0)
    p = strstr (json, "\"content\"");
  if (p == 0)
    return 0;

  p = strchr (p, ':');
  if (p == 0)
    return 0;
  p++;
  p = baish_skip_ws (p);
  if (*p != '"')
    return 0;

  return baish_json_parse_string (&p);
}

static int
baish_parse_answer_commands (const char *s, char **answerp, char ***cmdsp, int *ncmdsp)
{
  const char *p;
  char *answer;
  char **cmds;
  int ncmds;
  int i;

  answer = 0;
  cmds = 0;
  ncmds = 0;

  if (s == 0)
    return 0;

  p = strchr (s, '{');
  if (p == 0)
    return 0;
  p++;

  while (*p)
    {
      char *key;

      p = baish_skip_ws (p);
      if (*p == '}')
        break;
      if (*p == ',')
        {
          p++;
          continue;
        }
      if (*p != '"')
        goto fail;

      key = baish_json_parse_string (&p);
      if (key == 0)
        goto fail;

      p = baish_skip_ws (p);
      if (*p != ':')
        {
          free (key);
          goto fail;
        }
      p++;
      p = baish_skip_ws (p);

      if (STREQ (key, "answer"))
        {
          free (key);
          if (*p != '"')
            goto fail;
          if (answer)
            free (answer);
          answer = baish_json_parse_string (&p);
          if (answer == 0)
            goto fail;
        }
      else if (STREQ (key, "commands"))
        {
          int cap = 4;

          free (key);
          if (*p != '[')
            goto fail;
          p++;
          if (cmds)
            {
              for (i = 0; i < ncmds; i++)
                if (cmds[i])
                  free (cmds[i]);
              free (cmds);
            }
          cmds = (char **)xmalloc (cap * sizeof (char *));
          ncmds = 0;

          while (*p)
            {
              p = baish_skip_ws (p);
              if (*p == ']')
                { p++; break; }
              if (*p == ',')
                { p++; continue; }
              if (*p != '"')
                goto fail;
              if (ncmds >= cap)
                {
                  cap *= 2;
                  cmds = (char **)xrealloc (cmds, cap * sizeof (char *));
                }
              cmds[ncmds++] = baish_json_parse_string (&p);
              if (cmds[ncmds-1] == 0)
                goto fail;
            }
        }
      else
        {
          free (key);
          if (*p == '"')
            {
              char *tmp = baish_json_parse_string (&p);
              if (tmp)
                free (tmp);
            }
          else
            {
              while (*p && *p != ',' && *p != '}')
                p++;
            }
        }
    }

  if (answer == 0)
    answer = savestring (s);

  *answerp = answer;
  *cmdsp = cmds;
  *ncmdsp = ncmds;
  return 1;

fail:
  if (answer)
    free (answer);
  if (cmds)
    {
      for (i = 0; i < ncmds; i++)
        if (cmds[i])
          free (cmds[i]);
      free (cmds);
    }
  return 0;
}

static char *
baish_join_commands (char **cmds, int ncmds)
{
  int i;
  size_t cap, len;
  char *out;

  if (ncmds <= 0)
    return savestring ("");

  cap = 1;
  for (i = 0; i < ncmds; i++)
    cap += strlen (cmds[i]) + 1;

  out = (char *)xmalloc (cap);
  len = 0;
  for (i = 0; i < ncmds; i++)
    {
      size_t l = strlen (cmds[i]);
      memcpy (out + len, cmds[i], l);
      len += l;
      out[len++] = (i == ncmds - 1) ? '\0' : '\n';
    }
  out[len] = '\0';
  return out;
}

static int
baish_confirm_exec (int ncmds)
{
  char buf[32];

  if (interactive_shell == 0)
    return 0;
  if (isatty (fileno (stdin)) == 0)
    return 0;

  fprintf (stderr, "baish: execute %d command(s)? [y/N] ", ncmds);
  fflush (stderr);
  if (fgets (buf, sizeof (buf), stdin) == 0)
    return 0;
  return (buf[0] == 'y' || buf[0] == 'Y');
}

int
ask_builtin (WORD_LIST *list)
{
  char *question;
  char *escaped;
  char *body;
  char *host, *port, *base_path;
  char *path;
  char *resp;
  char *json;
  char *content;
  char *answer;
  char **cmds;
  int ncmds;
  char *joined;
  int i;
  int do_exec;
  int status;

  const char *base_url = get_string_value ("BAISH_OPENAI_BASE_URL");
  const char *model = get_string_value ("BAISH_MODEL");
  const char *autoexec = get_string_value ("BAISH_AUTOEXEC");
  const char *api_key = get_string_value ("OPENAI_API_KEY");

  if (base_url == 0)
    base_url = get_string_value ("OPENAI_BASE_URL");
  if (base_url == 0)
    base_url = "http://puck.local/v1";

  if (model == 0)
    model = get_string_value ("OPENAI_MODEL");
  if (model == 0)
    model = "gpt-4o-mini";

  if (list)
    {
      size_t cap = 0;
      size_t len = 0;
      WORD_LIST *t;
      char *q;

      for (t = list; t; t = t->next)
        cap += strlen (t->word->word) + 1;
      q = (char *)xmalloc (cap + 1);
      for (t = list; t; t = t->next)
        {
          size_t l = strlen (t->word->word);
          memcpy (q + len, t->word->word, l);
          len += l;
          if (t->next)
            q[len++] = ' ';
        }
      q[len] = '\0';
      question = q;
    }
  else
    {
      size_t qlen;
      question = baish_slurp_stream (stdin, &qlen);
      if (qlen == 0)
        {
          free (question);
	  builtin_error (_("missing question"));
          return (EXECUTION_FAILURE);
        }
    }

  host = port = base_path = 0;
  if (baish_parse_http_base_url (base_url, &host, &port, &base_path) == 0)
    {
	  builtin_error (_("BAISH_OPENAI_BASE_URL must be http://host:port/v1"));
      free (question);
      return (EXECUTION_FAILURE);
    }

  {
    const char *suffix = "/chat/completions";
    size_t bl = strlen (base_path);
    int need_slash = (bl == 0 || base_path[bl - 1] != '/');

    path = (char *)xmalloc (bl + strlen (suffix) + (need_slash ? 1 : 0) + 1);
    strcpy (path, base_path);
    if (need_slash)
      strcat (path, "/");
    strcat (path, suffix + 1);
  }

  escaped = baish_json_escape (question);
  body = (char *)xmalloc (strlen (escaped) + strlen (model) + 1024);
  sprintf (body,
           "{"
           "\"model\":\"%s\","
           "\"stream\":false,"
           "\"messages\":["
           "{\"role\":\"system\",\"content\":\"You are baish, an interactive shell assistant. Reply with strict JSON only: {\\\"answer\\\":string,\\\"commands\\\":[string,...]}. Put any shell commands to run into commands; otherwise commands should be []. Do not include any other text.\"},"
           "{\"role\":\"user\",\"content\":\"%s\"}"
           "]"
           "}",
           model, escaped);

  resp = baish_http_post (host, port, path, api_key, body);
  free (question);
  free (escaped);
  free (body);
  free (host);
  free (port);
  free (base_path);
  free (path);

  if (resp == 0)
    {
      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
	  builtin_error (_("request failed"));
      return (EXECUTION_FAILURE);
    }

  json = baish_http_body (resp);
  free (resp);
  if (json == 0)
    {
      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
	  builtin_error (_("invalid HTTP response"));
      return (EXECUTION_FAILURE);
    }

  content = baish_extract_message_content (json);
  free (json);
  if (content == 0)
    {
      bind_variable ("BAISH_LAST_ANSWER", "", 0);
      bind_variable ("BAISH_LAST_COMMANDS", "", 0);
	  builtin_error (_("could not parse response"));
      return (EXECUTION_FAILURE);
    }

  answer = 0;
  cmds = 0;
  ncmds = 0;
  if (baish_parse_answer_commands (content, &answer, &cmds, &ncmds) == 0)
    {
      answer = savestring (content);
      cmds = 0;
      ncmds = 0;
    }
  free (content);

  joined = baish_join_commands (cmds, ncmds);
  bind_variable ("BAISH_LAST_ANSWER", answer, 0);
  bind_variable ("BAISH_LAST_COMMANDS", joined, 0);

  printf ("%s\n", answer);
  fflush (stdout);

  do_exec = 0;
  if (ncmds > 0)
    {
      if (baish_truthy (autoexec))
        do_exec = 1;
      else
        {
          int j;
          for (j = 0; j < ncmds; j++)
            fprintf (stderr, "baish: command[%d]: %s\n", j + 1, cmds[j]);
          do_exec = baish_confirm_exec (ncmds);
        }
    }

  status = EXECUTION_SUCCESS;
  if (do_exec)
    {
      for (i = 0; i < ncmds; i++)
        {
          int r;
          r = parse_and_execute (savestring (cmds[i]), "ask", SEVAL_NOHIST|SEVAL_RESETLINE);
          status = r;
        }
    }

  if (cmds)
    {
      for (i = 0; i < ncmds; i++)
        if (cmds[i])
          free (cmds[i]);
      free (cmds);
    }
  free (joined);
  free (answer);

  return status;
}